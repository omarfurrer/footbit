<?php

namespace App\Services;

use App\Repositories\Eloquent\TournamentsRepositoryEloquent;
use App\Repositories\Eloquent\MatchesRepositoryEloquent;
use App\Repositories\Eloquent\TeamsRepositoryEloquent;
use App\Repositories\Eloquent\RefereesRepositoryEloquent;
use App\Entities\TournamentTypes;
use App\Entities\TournamentStatuses;
use App\Models\Tournament;
use Carbon\Carbon;

class TournamentManagerService {

    /**
     * Tournaments Repository.
     *
     * @var  TournamentsRepositoryEloquent
     */
    protected $tournamentsRepository;

    /**
     * Teams Repository.
     *
     * @var  TeamsRepositoryEloquent
     */
    protected $teamsRepository;

    /**
     * Referees Repository.
     *
     * @var  RefereesRepositoryEloquent
     */
    protected $refereesRepository;

    /**
     * Matches Repository.
     *
     * @var  MatchesRepositoryEloquent
     */
    protected $matchesRepository;

    /**
     * Array of error messages generated by the tournament manager.
     *
     * @var array
     */
    protected $errorMessages = [];

    /**
     * Tournament
     *
     * @var Tournament
     */
    protected $tournament;

    /**
     * Total number of rounds to be played in the tournament loaded.
     *
     * @var Integer
     */
    protected $numberOfRounds;

    /**
     * Total number of matches to be played in the tournament loaded.
     *
     * @var Integer
     */
    protected $numberOfMatches;

    /**
     * Default constructor.
     *
     * @param TournamentsRepositoryEloquent $tournamentsRepository
     * @param TeamsRepositoryEloquent $teamsRepository
     * @param RefereesRepositoryEloquent $refereesRepository
     * @param MatchesRepositoryEloquent $matchesRepository
     */
    public function __construct(TournamentsRepositoryEloquent $tournamentsRepository, TeamsRepositoryEloquent $teamsRepository, RefereesRepositoryEloquent $refereesRepository,
            MatchesRepositoryEloquent $matchesRepository)
    {
        $this->tournamentsRepository = $tournamentsRepository;
        $this->teamsRepository = $teamsRepository;
        $this->refereesRepository = $refereesRepository;
        $this->matchesRepository = $matchesRepository;
    }

    /**
     * Reset the data for the manager class.
     */
    public function reset()
    {
        $this->errorMessages = [];
        $this->tournament = null;
        $this->numberOfMatches = null;
        $this->numberOfRounds = null;
    }

    /**
     * Load a tournament in the manager.
     *
     * @param Integer $id
     * @return boolean
     */
    public function load($id)
    {
        $this->reset();

        $tournament = $this->tournamentsRepository->find($id);

        if (!$tournament) {
            return $tournament;
        }

        $this->tournament = $tournament;

        $this->numberOfMatches = $this->tournament->third_prize != NULL ? $this->tournament->number_of_teams : ($this->tournament->number_of_teams - 1);

        $this->numberOfRounds = (Integer) log($this->tournament->number_of_teams, 2);

        return true;
    }

    /**
     * Reload the manager with the same tournament to update any changes.
     *
     * @return boolean
     */
    public function reload()
    {
        return $this->load($this->tournament->id);
    }

    /**
     * Check some rules specific to each tournament type.
     *
     * @param array $data
     * @return boolean
     */
    public function validateTypeRules($data)
    {
        $typeValue = $data['type'];
        $numberOfTeams = $data['number_of_teams'];

        $valid = true;

        switch ($typeValue) {
            case TournamentTypes::KNOCKOUTS :

                // Check number of teams is correct
                if (!$this->_validateNumberOfTeams($typeValue, $numberOfTeams)) {
                    $this->_addErrorMessage('For knockouts, the number of teams must be a power of 2.');
                    $valid = false;
                }


                break;

            case TournamentTypes::TWO_WAY_KNOCKOUTS :

                break;
        }

        return $valid;
    }

    /**
     * Create a new tournament.
     * Return false IF rules are not fulfilled.
     *
     * @param array $data
     * @return boolean|Tournament
     */
    public function create($data)
    {
        $valid = $this->validateTypeRules($data);

        if (!$valid) {
            return $valid;
        }

        $tournament = $this->tournamentsRepository->create($data);

        // load the tournament in the manager in case we want to use it again.
        $this->load($tournament->id);

        $this->generateMatches();

        return $tournament;
    }

    /**
     * Update the tournament and do some other update specific checks and changes.
     *
     * @param array $data
     * @return boolean|Tournament
     */
    public function update($data = [])
    {
        // process checks for attributes that cannot be changed after the tournament has started
        if ($this->tournament->status >= TournamentStatuses::STARTED) {
            // IF number of teams has changed.
            if ($this->tournament->number_of_teams != $data['number_of_teams']) {
                $this->_addErrorMessage('You cannot change the number of teams when the tournament is set to @tournamentstatus(' . $this->tournament->status . ')');
                return false;
            }
        }

        $oldModel = $this->tournament;

        $tournament = $this->tournamentsRepository->update($data, $this->tournament->id);

        $this->reload();

        // If number of teams has changed
        // regenerate matches
        if ($oldModel->number_of_teams != $this->tournament->number_of_teams) {
            $this->generateMatches();
        }

        /**
         * TODO : IF default venue has changed update all matches which haven't started yet and which had the default value set.
         */
        /**
         * TODO : IF default match duration has changed update all matches which haven't started yet and which had the default value set.
         */
        /**
         * TODO : IF tournament name has changed update all match names to match new tournament name.
         */
        return $this->tournament;
    }

    /**
     * Do some checks and update the tournament teams if passed.
     *
     * @param array $teams
     * @return boolean|Tournament
     */
    public function updateTeams($teams)
    {
        // IF tournament status is not ready or pending teams then we cannot change teams.
        if ($this->tournament->status >= TournamentStatuses::STARTED) {
            $this->_addErrorMessage('You cannot change teams when the tournament status is set to @tournamentstatus(' . $this->tournament->status . ')');
            return false;
        }

        $teamsCount = count($teams);

        // check the number of teams chosen is not higher than the allowed number.
        if ($teamsCount > $this->tournament->number_of_teams) {
            $this->_addErrorMessage('You chose ' . $teamsCount . ' teams to play in ' . $this->tournament->name . '. The maximum number allowed is ' . $this->tournament->number_of_teams . '.');
            return false;
        }

        $data = ['teams' => $teams];

        // IF all teams were chosen then mark the tournament as ready to play.
        if ($teamsCount == $this->tournament->number_of_teams) {
            $data['status'] = TournamentStatuses::READY;
        } else {
            $data['status'] = TournamentStatuses::PENDING_TEAMS;
        }

        $this->tournamentsRepository->update($data, $this->tournament->id);

        /**
         * If teams have been changed && First round teams have been chosen (randomized)
         * THEN IF all teams have been rechosen, randomize first round teams again.
         */
        return $this->tournament;
    }

    /**
     * Generate all the tournament matches with empty players and default tournament match values.
     *
     * @return Tournament
     */
    public function generateMatches()
    {
        $this->resetMatches();

        switch ($this->tournament->type) {
            case TournamentTypes::KNOCKOUTS :

                $numberOfMatchesForCurrentRound = $this->tournament->number_of_teams / 2;

                $data = [
                    'duration' => $this->tournament->default_match_time,
                    'venue_id' => $this->tournament->default_venue_id,
                    'tournament_id' => $this->tournament->id
                ];

                // Rounds
                for ($i = $this->numberOfRounds; $i >= 1; $i--) {

                    $data['round'] = $i;

                    // Matches per round
                    for ($j = 1; $j <= $numberOfMatchesForCurrentRound; $j++) {
                        $data['name'] = $this->tournament->name . ' R' . $i . ' M' . $j;
                        $this->matchesRepository->create($data);
                    }

                    // Third prize loser vs loser
                    if ($this->numberOfRounds > 1 && $i == 2 && $this->tournament->third_prize != NULL) {
                        $data['name'] = $this->tournament->name . ' R' . $i . ' M3 Loser vs Loser for third prize.';
                        $this->matchesRepository->create($data);
                    }

                    $numberOfMatchesForCurrentRound /= 2;
                }

                break;

            case TournamentTypes::TWO_WAY_KNOCKOUTS :

                break;
        }

        return $this->tournament;
    }

    /**
     * Randomize the teams and assign them to matches for the first round in the tournament.
     *
     * @return boolean|Tournament
     */
    public function randomizeFirstRoundTeams()
    {
        // check all teams have been assigned
        if (!$this->checkAllTeamsHaveBeenAssigned()) {
            $this->_addErrorMessage('Cannot randomzie teams for first round because not all teams were assigned in the tournament');
            return false;
        }

        // IF tournament status is not ready or pending teams then we cannot change teams.
        if ($this->tournament->status >= TournamentStatuses::STARTED) {
            $this->_addErrorMessage('You cannot randomize teams when the tournament status is set to @tournamentstatus(' . $this->tournament->status . ')');
            return false;
        }

        switch ($this->tournament->type) {
            case TournamentTypes::KNOCKOUTS :
                $teams = collect($this->tournamentsRepository->listTeamsInRandomOrder($this->tournament->id));
                $matches = $this->matchesRepository->getTournamentMatchesByRound($this->tournament->id, $this->numberOfRounds);

                $teamGroups = $teams->split($matches->count())->toArray();

                foreach ($teamGroups as $key => $group) {
                    $group = array_values($group);
                    $firstTeam = $group[0];
                    $secondTeam = $group[1];
                    $this->matchesRepository->update(['first_team_id' => $firstTeam, 'second_team_id' => $secondTeam], $matches[$key]->id);
                }

                break;

            case TournamentTypes::TWO_WAY_KNOCKOUTS :

                break;
        }

        return $this->tournament;
    }

    /**
     * Using and array of matches, update the schedule of the tournament.
     *
     * @param array $matches
     * @return boolean
     */
    public function updateSchedule($matches)
    {
        foreach ($matches as $matchID => $match) {
            if (!empty($match['starting_at'])) {
                $match['starting_at'] = Carbon::createFromFormat('M j, Y g:i A', $match['starting_at']);
            }
            $this->matchesRepository->update($match, $matchID);
        }

        return true;
    }

    /**
     * Get tournament matches.
     *
     * @param mixed $timeDirection
     * @param string $orderBy
     * @param string $order
     * @return Collection
     */
    public function getMatches($timeDirection = null, $orderBy = 'id', $order = 'DESC')
    {
        $matches = [];
        switch ($timeDirection) {
            case 'past':
                $matches = $this->matchesRepository->getPastMatchesByTournamentID($this->tournament->id);
                break;
            case 'present':
                $matches = $this->matchesRepository->getPresentMatchesByTournamentID($this->tournament->id);
                break;
            case 'future':
                $matches = $this->matchesRepository->getFutureMatchesByTournamentID($this->tournament->id);
                break;
            default:
                $matches = $this->matchesRepository->getTournamentMatches($this->tournament->id);
                break;
        }
        return $matches->sortBy($orderBy);
    }

    /**
     * TODO : DOCS and change name maybe to getMatchesDiagram
     */
    public function getDiagramData()
    {

        // first round team names to play in pairs
        $teams = [];
        // first round matches
        $matches = $this->matchesRepository->getTournamentMatchesByRound($this->tournament->id, $this->numberOfRounds);
        foreach ($matches as $match) {
            $teams[] = [$match->firstTeam == null ? null : $match->firstTeam->name, $match->secondTeam == null ? null : $match->secondTeam->name];
        }

        return ['teams' => $teams];
    }

    /**
     * Return true if all teams have been assigned in the tournament.
     *
     * @return boolean
     */
    public function checkAllTeamsHaveBeenAssigned()
    {
        return $this->tournament->number_of_teams == $this->tournament->teams()->count();
    }

    /**
     * Delete all matches of the tournament.
     * Returns true If found at least one match to delete.
     *
     * @return boolean
     */
    public function resetMatches()
    {
        if (!$this->matchesRepository->deleteByTournamentID($this->tournament->id)) {
            return false;
        }
        return true;
    }

    /**
     * Retrieve the matches grouped by round.
     *
     * @return \Illuminate\Support\Collection
     */
    public function getMatchesForSchedule()
    {
        return $this->matchesRepository->getTournamentMatchesGroupedByRound($this->tournament->id);
    }

    /**
     * Get a list of eligble referees to be assigned to matches in this tournament. [id=>name]
     */
    public function getEligbleRefereesList()
    {
        return $this->refereesRepository->getList();
    }

    /**
     * Validate that number of teams is correct for the knockouts type.(Power of 2)
     *
     * @param Integer $type
     * @param Integer $numberOfTeams
     * @return boolean
     */
    protected function _validateNumberOfTeams($type, $numberOfTeams)
    {
        switch ($type) {
            case TournamentTypes::KNOCKOUTS :
                return ($numberOfTeams & ($numberOfTeams - 1)) == 0;
        }
    }

    /**
     * Add an error message to the array of error messages.
     *
     * @param String $message
     */
    protected function _addErrorMessage($message)
    {
        $this->errorMessages[] = $message;
    }

    /**
     * Retrieve all error messages for this instance.
     *
     * @return array
     */
    public function getErrorMessages()
    {
        return $this->errorMessages;
    }

}
